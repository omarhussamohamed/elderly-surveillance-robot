# Firmware Troubleshooting Guide

This guide covers common issues and solutions for the Elderly Bot ESP32 firmware.

## Quick Reference

### Most Common Issues

1. **"Unable to sync with device"** → See [rosserial Connection Issues](#rosserial-connection-issues)
2. **LWIP crash / continuous reboots** → See [LWIP Crash Fix](#lwip-crash-fix)
3. **Compilation errors (LEDC functions)** → See [ESP32 Core Compatibility](#esp32-core-compatibility)
4. **Topics not appearing** → See [rosserial Connection Issues](#rosserial-connection-issues)

---

## ESP32 Core Compatibility

**CRITICAL**: This firmware requires **ESP32 Arduino Core 2.0.17**. Do NOT use Core 3.x.

### Why Core 2.0.17?

- Proven stability with rosserial
- No compatibility layer needed
- No TCP/IP initialization issues
- Well-tested in ROS applications

### Installation

1. Open Arduino IDE
2. Go to **Tools → Board → Boards Manager**
3. Search for "esp32"
4. Select version **2.0.17** from dropdown
5. Click **Install**

### Verification

```bash
# Check installed version
arduino-cli core list
# Should show: esp32:esp32  2.0.17
```

### If You Must Use Core 3.x

The firmware includes a compatibility layer, but Core 2.0.17 is strongly recommended. See `ESP32_CORE_COMPATIBILITY.md` for detailed technical information.

---

## rosserial Connection Issues

### Error: "Unable to sync with device"

This means rosserial_python cannot establish communication with the ESP32.

#### Solution (3 Steps)

**Step 1: Regenerate ros_lib on Jetson Nano**
```bash
cd ~/Arduino/libraries
rm -rf ros_lib
rosrun rosserial_arduino make_libraries.py .
```

**Step 2: Re-upload Firmware to ESP32**
1. Open Arduino IDE
2. Open `firmware/elderly_bot_esp32.ino`
3. Verify Board: "ESP32 Dev Module"
4. Verify Port: `/dev/ttyUSB0` (or your ESP32 port)
5. Click Upload
6. **CRITICAL**: Must re-upload after regenerating ros_lib

**Step 3: Test Connection**
```bash
# Terminal 1
roscore

# Terminal 2
rosrun rosserial_python serial_node.py _port:=/dev/ttyUSB0 _baud:=115200
```

#### Expected Output

```
[INFO] ROS Serial Python Node
[INFO] Connecting to /dev/ttyUSB0 at 115200 baud
[INFO] Requesting topics...
[INFO] Setup subscriber on cmd_vel [geometry_msgs/Twist]
[INFO] Setup publisher on wheel_odom [nav_msgs/Odometry]
[INFO] Setup publisher on imu/data [sensor_msgs/Imu]
```

#### Verify It Works

```bash
# Check topics exist
rostopic list
# Should show: /cmd_vel, /wheel_odom, /imu/data

# Check publishing rates
rostopic hz /wheel_odom  # Should show ~100 Hz
rostopic hz /imu/data    # Should show ~100 Hz
```

### Why This Happens

The `ros_lib` library on the ESP32 must be generated on the **same system** running rosserial_python (your Jetson Nano). If you generated ros_lib on a different computer or with a different ROS version, it won't match.

### Additional Troubleshooting

#### Verify Serial Connection

```bash
# Install screen if needed
sudo apt-get install screen

# Monitor serial output
screen /dev/ttyUSB0 115200
```

**Expected output**: Boot messages and debug output.

**If no output**:
- Check USB cable
- Verify port: `ls -l /dev/ttyUSB*`
- Check baud rate (must be 115200)

Press `Ctrl+A` then `K` to exit screen.

#### Check ros_lib Version

```bash
# Check if ros_lib exists
ls ~/Arduino/libraries/ros_lib/

# Check ros.h version
grep "ROS_VERSION" ~/Arduino/libraries/ros_lib/ros.h
```

#### Verify Arduino Libraries

Required libraries in `~/Arduino/libraries/`:
- `ros_lib/` (generated by rosserial)
- `Rosserial_Arduino_Library/` (from Arduino Library Manager)
- `MPU9250/` (from Arduino Library Manager)

**Install missing libraries**:
1. Open Arduino IDE
2. Sketch → Include Library → Manage Libraries
3. Search and install:
   - "Rosserial Arduino Library"
   - "MPU9250" by hideakitai

#### Check Firmware Compilation

```bash
# Using arduino-cli
arduino-cli compile --fqbn esp32:esp32:esp32 elderly_bot_esp32.ino
```

**Common compilation errors**:
- `ros.h: No such file or directory` → ros_lib not generated
- `MPU9250.h: No such file or directory` → Install MPU9250 library
- LEDC errors → Wrong ESP32 core version (use 2.0.17)

---

## LWIP Crash Fix

### Symptoms

- `assert failed: tcpip_send_msg_wait_sem (Invalid mbox)`
- Continuous reboot loop
- ESP32 crashes immediately after boot

### Root Cause

Even on Core 2.0.17, rosserial can trigger LWIP initialization because the ESP32 WiFi stack auto-initializes. Since rosserial uses **USB serial only** (no network needed), we must disable WiFi completely.

### The Fix

The firmware disables WiFi at startup to prevent LWIP initialization. If you're still experiencing crashes:

1. **Verify firmware is up to date** - The current firmware includes WiFi disable code
2. **Upload firmware** - Re-upload `elderly_bot_esp32.ino` to ESP32
3. **Monitor serial output** - Should see clean boot without crashes

### Expected Serial Output (After Fix)

```
=== Elderly Bot ESP32 Starting ===
Initializing hardware...
Motors initialized
Encoders initialized
MPU-9250 is online...
Calibrating IMU - keep robot still...
IMU initialized
Initializing ROS node...
Waiting for ROS connection...
```

### If Still Getting LWIP Crash

**Check compilation output**:
1. File → Preferences
2. Check "Show verbose output during: compilation"
3. Compile again
4. Look for: `esp32\hardware\esp32\2.0.17` in paths
5. If you see `3.3.5` anywhere → wrong core is being used

**Force clean build**:
```bash
# Close Arduino IDE
# Remove build cache (Windows PowerShell)
Remove-Item -Recurse -Force "$env:TEMP\arduino_build_*"
Remove-Item -Recurse -Force "$env:TEMP\arduino_cache_*"
# Reopen Arduino IDE and compile
```

---

## Other Common Issues

### Error: "Checksum does not match"

**Cause**: Serial communication errors, wrong baud rate, or buffer overflow

**Solution**:
- Verify baud rate is 115200 on both sides
- Check USB cable quality
- Increase buffer size (already done in updated firmware)
- Reduce message publishing rate

### Connection drops after a few seconds

**Cause**: Buffer overflow or message too large

**Solution**: Updated firmware now has 512-byte buffers, should handle this. If still occurring, check for memory issues.

### ESP32 keeps rebooting

**Cause**: LWIP crash (usually Core 3.x issue) or power supply problems

**Solution**:
- Use ESP32 Arduino Core 2.0.17 (see [ESP32 Core Compatibility](#esp32-core-compatibility))
- Check power supply (ESP32 needs stable 5V)
- Verify USB cable quality

### Topics not appearing

**Cause**: Topics not advertised or subscription failed

**Solution**:
- Check serial monitor for "Setup publisher/subscriber" messages
- Verify `nh.advertise()` and `nh.subscribe()` are called in firmware
- Check for memory issues (ESP32 running out of RAM)
- Verify rosserial connection is established

### Serial output garbled

**Cause**: Wrong baud rate or USB connection issues

**Solution**:
- Check baud rate: 115200
- Try different USB cable
- Check USB-to-serial chip drivers
- Press ESP32 reset button

### "Waiting for ROS connection..." forever

**On Jetson side**:
1. Check roscore is running: `rosnode list`
2. Check port is correct: `ls -l /dev/ttyUSB*`
3. Check permissions: `groups` (should include dialout)
4. Try: `sudo chmod 666 /dev/ttyUSB0`

**On ESP32 side**:
1. Check serial monitor shows "Waiting for ROS connection..."
2. No crashes or reboots
3. If stuck, press reset button on ESP32

---

## Advanced Debugging

### Enable rosserial Debug Output

Modify firmware to add debug output:

```cpp
// In setup(), after nh.initNode()
nh.loginfo("Node initialized");
nh.loginfo("Advertising topics...");
```

### Check ESP32 Memory

Add to setup():

```cpp
Serial.print("Free heap: ");
Serial.println(ESP.getFreeHeap());
```

Should show > 100KB free.

### Test Minimal Firmware

Create a minimal test to isolate the issue:

```cpp
#include <ros.h>
#include <std_msgs/String.h>

ros::NodeHandle nh;
std_msgs::String str_msg;
ros::Publisher test_pub("test", &str_msg);

void setup() {
  Serial.begin(115200);
  delay(1000);
  nh.initNode();
  nh.advertise(test_pub);
}

void loop() {
  str_msg.data = "hello";
  test_pub.publish(&str_msg);
  nh.spinOnce();
  delay(1000);
}
```

If this works, the issue is with the full firmware (likely buffer size or message complexity).

---

## Verification Checklist

After fixing issues, verify:

- [ ] Firmware compiles without errors
- [ ] Firmware uploads successfully
- [ ] Serial output shows boot messages
- [ ] rosserial connects without "Unable to sync" error
- [ ] Topics appear in `rostopic list`
- [ ] `/wheel_odom` publishes at ~100 Hz
- [ ] `/imu/data` publishes at ~100 Hz
- [ ] `/cmd_vel` can be published and received by ESP32
- [ ] Motors respond to velocity commands
- [ ] No disconnections or crashes

---

## Key Points to Remember

1. **ALWAYS regenerate ros_lib on the target system (Jetson)**
2. **ALWAYS re-upload firmware after regenerating ros_lib**
3. **Use ESP32 Arduino Core 2.0.17** (not 3.x)
4. **Baud rate must be 115200** on both sides
5. **Buffer sizes matter** for large messages like Odometry

---

## Related Documentation

- `ESP32_CORE_COMPATIBILITY.md` - Detailed technical information about ESP32 Core versions
- `FIRMWARE_CHANGES.md` - Changelog of firmware updates
- `README.md` - Main project documentation

---

## Still Having Issues?

If problems persist after following this guide:

1. Check ESP32 Arduino Core version (must be 2.0.17)
2. Verify ROS Melodic installation
3. Test with a simple rosserial example first
4. Check for hardware issues (USB cable, power supply)
5. Review ESP32 serial monitor for error messages

## References

- rosserial_arduino: http://wiki.ros.org/rosserial_arduino
- rosserial troubleshooting: http://wiki.ros.org/rosserial_python/Troubleshooting
- ESP32 Arduino Core 2.0.17: https://github.com/espressif/arduino-esp32/releases/tag/2.0.17

